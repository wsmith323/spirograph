Plan-Id: 2026-02-25_230203Z-enforce-physical-pen-offset-bound-random-generation

# Enforce Physical Pen-Offset Bound (`d <= r`) in Random Generation

## Summary

Fix the random-generation constraint mismatch so `RandomConstraintMode.PHYSICAL`
actually enforces a physical pen-offset bound: the randomly generated pen offset
(`d`) must not exceed the rolling radius (`r`).

This aligns runtime behavior with the console UI’s `physical` constraint meaning
and prevents analysis output from correctly reporting “pen outside roller” for a
curve that was supposedly generated under physical constraints.

## Goals and Success Criteria

- In `physical` random constraint mode, random pen offset generation must always
  satisfy `d <= r`.
- `extended` and `wild` modes keep their current looser behavior.
- No changes to manual entry or lock behavior semantics (this is a random helper
  fix only).
- Add regression tests so the physical constraint cannot silently drift again.

Success criteria:
- `random_pen_offset(..., constraint=PHYSICAL, ...)` never returns a value
  greater than `rolling_radius`.
- Existing tests pass, plus new tests for console UI random helpers.

## In Scope

- `/Users/warren/work/projects/spirograph/spirograph/console_ui/random.py`
- New tests under `/Users/warren/work/projects/spirograph/tests/spirograph/console_ui/`
  (recommended: `test_random.py`)

## Out of Scope

- Changes to analysis wording/heuristics
- Changes to manual input validation
- Changes to locking behavior UI
- Changes to rolling-radius random constraint logic
- Changes to generator/renderer math

## Public APIs / Interfaces / Types

No public API changes.

Function behavior change only:
- `random_pen_offset(...)` will enforce a stricter upper bound in
  `RandomConstraintMode.PHYSICAL`.

## Design Decisions (Locked)

## 1. Physical mode pen-offset cap is inclusive (`d <= r`)

Implement physical-mode cap as:
- `base_max = rolling_radius` (equivalently `int(rolling_radius)` in current
  integer-based random helper flow)

Reason:
- User explicitly asked to cap at `r`
- Inclusive bound matches “on the rim” as physically plausible
- Avoids unnecessary off-by-one semantics like `r - 1`

## 2. Keep existing non-physical modes unchanged

- `EXTENDED`: preserve current `max_factor = 1.6`
- `WILD`: preserve current `max_factor *= 1.5`

Reason:
- Bug is a physical-mode invariant mismatch, not a general retuning request.

## 3. Keep evolution behavior unchanged

Do not change `evolve_value(...)`.

Only change how `random_pen_offset(...)` computes `base_max` by constraint.

Reason:
- Minimizes risk and keeps drift/jump/random evolution semantics stable.

## Implementation Changes (Decision Complete)

In `spirograph/console_ui/random.py`, update `random_pen_offset(...)`:

Current behavior (problem):
- `max_factor = 1.6` for both `PHYSICAL` and `EXTENDED`
- `base_max = int(rolling_radius * max_factor)`

New behavior:
- `PHYSICAL`:
  - `base_min = 1`
  - `base_max = max(1, int(rolling_radius))`
- `EXTENDED`:
  - keep current factor-based behavior (`1.6`)
- `WILD`:
  - keep current factor-based behavior (`1.6 * 1.5`)

Implementation style:
- Use explicit `if/elif/else` by `RandomConstraintMode` (clearer than implicit
  factor defaults for this invariant-sensitive case).

## Test Plan (Automated)

Create a new test module:
- `/Users/warren/work/projects/spirograph/tests/spirograph/console_ui/test_random.py`

Use `pytest` (project already uses pytest).

### Tests to add

1. `physical` mode caps at rolling radius
- Monkeypatch `spirograph.console_ui.random.random.randint` to return the upper
  bound (or deterministic max path)
- Call `random_pen_offset(...)` with:
  - `rolling_radius = 45`
  - `constraint = RandomConstraintMode.PHYSICAL`
  - `evolution = RandomEvolutionMode.RANDOM`
- Assert result `<= 45`
- Prefer asserting exact `== 45` under patched max-return behavior

2. `extended` mode can exceed rolling radius (regression guard)
- Same monkeypatch strategy
- `rolling_radius = 45`
- `constraint = EXTENDED`
- Assert result `> 45` (with max-return behavior this should hit the upper bound)

3. `wild` mode remains at least as permissive as extended
- Same monkeypatch strategy
- Assert `wild_result >= extended_result` for the same `rolling_radius`

4. Physical mode with small rolling radius remains valid
- `rolling_radius = 1`
- `constraint = PHYSICAL`
- Assert result is exactly `1` (or at least `<= 1` and `>= 1`)

## Manual Scenarios (Console UI)

- Set random constraint mode to `physical`
- Generate multiple random curves
- Verify analysis no longer reports “pen outside roller” from random generation
  alone (unless using manual entry/locks that intentionally allow it)
- Switch to `extended`/`wild` and verify outside-roller descriptions still occur
  sometimes

## Validation Commands (Plan Defaults)

- Targeted:
  - `VIRTUAL_ENV=~/work/virtualenvs/spirograph ./scripts/test tests/spirograph/console_ui/test_random.py -q`
- Full suite:
  - `VIRTUAL_ENV=~/work/virtualenvs/spirograph ./scripts/test -q`

## Risks / Regression Potential

- Low risk: isolated change in random UI helper logic
- Potential subtlety if future code passes non-integer `rolling_radius` into
  `random_pen_offset(...)` (current random workflow uses ints)
- Manual/locked workflows can still create `d > r`, which is expected and should
  not be confused with this fix

## Assumptions and Defaults Chosen

- “Physical” means inclusive rim bound (`d <= r`)
- The fix applies only to random generation helpers, not manual entry
- Existing `extended` and `wild` tuning should remain unchanged
- Add a new `tests/spirograph/console_ui/test_random.py` module (no existing
  random-helper tests are present)

## Implementation Steps

1. Update `random_pen_offset(...)` in
   `/Users/warren/work/projects/spirograph/spirograph/console_ui/random.py` to
   enforce `d <= r` in `RandomConstraintMode.PHYSICAL`
2. Add pytest regression tests in
   `/Users/warren/work/projects/spirograph/tests/spirograph/console_ui/test_random.py`
3. Run targeted random-helper tests
4. Run full test suite
5. Stage changes in git (`git add ...`)
6. Run the `capture-last-plan` skill to persist this plan
